;
;
;******************************************************************************
;
;	Arquivo de Referência para o desenvolvimento do kernel.
;
;	Versão: 2020.2
;
;	Áreas de memória
;
;	0000 - 7FFF		_KERNEL
;					Área de Kernel para implementação dos alunos
;
;	0100 - 01FF		_VETTAB
;					Tabela com os vetores das funções do kernel
;					*** CUIDADO! Esse vetor esté no meio da área de código ***
;
;	8000 - FF7F		_APP
;					Área onde será colocado o programa de aplicação.
;					Esse programa vai fazer o acesso aos periféricos e interrupções, através das funções do Kernel.
;
;	FF80 - FFBF 	_IOAREA16
;					Area de perifericos, acessada na base 16 bits
;
;	FFC0 - FFFF		_IOAREA08
;					Area de perifericos, acessada na base 8 bits
;					
;******************************************************************************


_KERNEL:	equ	h0000
_VETTAB:	equ	h0100
_APP:		equ	h8000
_IOAREA16:	equ	hFF80
_IOAREA08:	equ	hFFC0


;
;------------------------------------------------------------------------------
;	Área reservada para os periféricos
;------------------------------------------------------------------------------

; Acesso em 16 bits
  org    _IOAREA16
  daw    [31]
IVET:	dw		0			; Vetor de interrupção

; Acesso em 8 bits
  org    _IOAREA08
  dab    [23]
TIMDT:	db		0			; Registro de programação do timer
INTS:	db		0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db		0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:	db		0			; Status do teclado
TECDT:	db		0			; Dado do teclado
VISOR:	dab		[36]		; Portas de acesso ao visor

;	
;------------------------------------------------------------------------------
;	Ponto de entrada do RESET do processador
;------------------------------------------------------------------------------
  org    _KERNEL
  jmp    _RESET

;
;------------------------------------------------------------------------------
;	Area do kernel com os vetores das funções do kernel
;------------------------------------------------------------------------------
  org    _VETTAB
  dw     _SETTEC
  dw     _PUTCHAR
  dw     _SETCLOCK
  dw     _GETCLOCK
  dw     _SETTIMER
  dw     _GETTIMER
		
;	
;------------------------------------------------------------------------------
;	Código de RESET (BOOT) do processador/interrupção
;------------------------------------------------------------------------------
  org    _VETTAB+h0100
_RESET:		
; 1) Desabilitar o sistema de interrupções
  CLR    INTE
; 2) Inicializar o stack pointer (SP = R6)
  MOV    #h7FFF, R6
; 3) Inicializar as variáveis internas usadas pelo sistema de interrupções e periféricos (IVET, INTE, etc.)
  MOV    #ISR, IVET
  CLR    INTS
; 4) Inicializar as variáveis internas do kernel
  CLR    cursor
  CLR    tabbing
  CLR rel_hora
  CLR rel_minuto
  CLR rel_segundo
  CLR rel_ms_counter
; 5) Inicializar o teclado zerando o byte de estado (TECST, endereço 65498)
  CLR    TECST
; 6) Inicializar o timer
  MOV    #10, TIMDT
; 7) Limpar o visor
  JSR    R7, limpaVisor
; 8) Habilitar interrupções
  MOV    #h81, INTE
; 9) Retornar para o programa de aplicação com um desvio para o endereço _APP da memória
  jmp    _APP


;	
;------------------------------------------------------------------------------
;	Área de variáveis
;------------------------------------------------------------------------------
end_struct_buffer: DW
cursor: DW
tabbing: DW
rel_hora: DW
rel_minuto: DW
rel_segundo: DW
rel_ms_counter: DW
timer_tempo: DW
;	
;------------------------------------------------------------------------------
;	Área de funções
;------------------------------------------------------------------------------

;função obtida da BibCesar, do livro "Fundamentos de arquitetura de computadores - Raul Weber"
limpaVisor:
  MOV    R0, -(R6)
  MOV    R1, -(R6)
  MOV    #VISOR, R1
  MOV    #36, R0
whileLimpaVisor:
  CLR    (R1)
  INC    R1
  SOB    R0, whileLimpaVisor
	
  MOV    (R6)+, R1
  MOV    (R6)+, R0	

  RTS    R7
;	
;------------------------------------------------------------------------------
;	Tratador de interrupções
;------------------------------------------------------------------------------
ISR:
  AND    #h7F, INTE 
  MOV    R0, -(R6)
  MOV    R1, -(R6)
  MOV    R2, -(R6)
  MOV    R3, -(R6)
  MOV    R4, -(R6)
  MOV    R5, -(R6)

  MOV    INTS, R0
  AND    #h01, R0                 ;testa bit int timer
  BNE    ISR_tim
  MOV    INTS, R0
  AND    #h02, R0                 ;testa bit int teclado
  BNE    ISR_tec
fim_ISR:
  MOV    (R6)+, R5
  MOV    (R6)+, R4
  MOV    (R6)+, R3
  MOV    (R6)+, R2
  MOV    (R6)+, R1
  MOV    (R6)+, R0
  OR     #h80, INTE               ;habilita interrupções
  RTI
ISR_tim:
  CMP timer_tempo, #0
  BEQ relogio
  SUB #10, timer_tempo
  CMP timer_tempo, #0
  BGE relogio
  CLR timer_tempo
relogio:
  INC rel_ms_counter
  CMP rel_ms_counter, #100  ;passou um segundo
  BLT fim_tim
  CLR rel_ms_counter
  INC rel_segundo 
  CMP rel_segundo, #60
  BLT fim_tim
  CLR rel_segundo 
  INC rel_minuto
  CMP rel_minuto, #60
  BLT fim_tim
  CLR rel_minuto
  INC rel_hora
  CMP rel_hora, #24
  BLT fim_tim
  CLR rel_hora
fim_tim:
  AND    #hFFFE, INTS             ;desliga bit int timer
  JMP    fim_ISR
ISR_tec:
  TST    TECST
  BEQ    fim_tec
  MOV    end_struct_buffer, R0
  MOV    (R0), R1                 ;R1 = ind_entrada
  MOV    2(R0), R2                ;R2 = ind_saida

  JSR    R7, bufferCheio          ;retorna no R3 se está cheio
  TST    R3
  BNE    fim_tec
  MOV    R1, R3
  ASL    R3                       ;indice*2
  ADD    R0, R3
  ADD    #4, R3                   ;R3 = end buffer + ind_entrada
  MOV    TECDT, (R3)              ;escreve o char na posicao de entrada do buffer

  INC    R1
  CMP    R1, #16
  BGE    reset_ind_buffer
  JMP    atualiza_ind_app
reset_ind_buffer:
  CLR    R1
atualiza_ind_app:
  MOV    R1, (R0)                 ;pos de memoria do indice = novo indice
fim_tec:
  CLR    TECST
  AND    #hFFFD, INTS             ;desliga bit int teclado
  JMP    fim_ISR

bufferCheio:
  MOV    R1, R3
  INC    R3
  CMP    R3, R2
  BEQ    b_cheio
  CMP    R3, #16
  BNE    b_vazio
  CMP    R2, #0
  BNE    b_vazio
b_cheio:
  MOV    #1, R3
  RTS    R7
b_vazio:
  CLR    R3
  RTS    R7
;		
;------------------------------------------------------------------------------
;	Informa ao kernel o endereço da estrutura de dados onde colocar as teclas que forem digitadas.
;	O endereço de início dessa estrutura será passado para o kernel através do registrador R5.
;------------------------------------------------------------------------------
_SETTEC:
  MOV    R5, end_struct_buffer
  OR     #h02, INTE               ;ativa int teclado
  CLR    R0                       ;retorno sucesso (como pode dar erro??) 
  rts    r7
		
;		
;------------------------------------------------------------------------------
;	Envia um caractere ASCII para o visor. 
;	Esse caractere pode ser um caractere visível (que tenha representação simbólica)
;		ou um caractere de controle.
;	O caractere é passado através do registrador R5.
;------------------------------------------------------------------------------
_PUTCHAR:
  MOV    R0, -(R6)

  MOV    cursor, R0
  TST    tabbing
  BNE    move_tab
  CMP    R5, #h20
  BLT    controle
  CMP    R5, #h7A
  BGT    controle
  MOV    R5, hFFDC(R0)            ;move char pra #visor+R0
  INC    cursor
  CMP    cursor, #35
  BLE    pula_reset_cursor
  CLR    cursor
pula_reset_cursor:
  JMP    fim_putchar
controle:
  CMP    R5, #h0D                 ;erro? TESTA DNV, PODE TER SIDO UM LF ANTES DO CR
  BEQ    carriage_return
  CMP    R5, #h0A
  BEQ    line_feed
  CMP    R5, #h08
  BEQ    back_space
  CMP    R5, #h09
  BEQ    horizontal_tab
  JMP    fim_putchar
carriage_return:
  CLR    cursor
  JMP    fim_putchar
line_feed:
  JSR    R7, limpaVisor
  JMP    fim_putchar
back_space:
	;CLR hFFDC(R0)	;limpa o char 
  TST    cursor
  BEQ    fim_putchar
  DEC    cursor
  JMP    fim_putchar
horizontal_tab:
  MOV    #1, tabbing
  JMP    fim_putchar
move_tab:
  CMP    R5, #35
  BGT    pula_tab
  MOV    R5, cursor
pula_tab:
  CLR    tabbing
  JMP    fim_putchar
	
fim_putchar:
  MOV    (R6)+, R0
  CLR    R0                       ;sucesso
  rts    r7
		
;		
;------------------------------------------------------------------------------
;	Atualiza a hora atual do relógio interno do kernel.
;	Informa a hora a ser usada em três palavras de 2 bytes na memória.
;	O endereço dessas três palavras será passado para a função através do registrador R5.
;------------------------------------------------------------------------------
_SETCLOCK:
  ;hora = (R5)
  ;minuto = 2(R5)
  ;segundo = 4(R5)
  CMP    (R5), #0
  BLT    erro_rel
  CMP    (R5), #23
  BGT    erro_rel
  CMP    2(R5), #0
  BLT    erro_rel
  CMP    2(R5), #59
  BGT    erro_rel
  CMP    4(R5), #0
  BLT    erro_rel
  CMP    4(R5), #59
  BGT    erro_rel

  MOV    (R5), rel_hora
  MOV    2(R5), rel_minuto
  MOV    4(R5), rel_segundo
  CLR    R0                    ;sucesso!
  RTS    R7

erro_rel:
  MOV    #1, R0                ;erro! valor inválido
  RTS    r7
		
;		
;------------------------------------------------------------------------------
;	Informa a hora atual do relógio interno do kernel.
;	Informa a hora em três palavras de 2 bytes na memória.
;	O endereço dessas três palavras será passada para a função através do registrador R5.
;------------------------------------------------------------------------------
_GETCLOCK:
  MOV    rel_hora, (R5)
  MOV    rel_minuto, 2(R5)
  MOV    rel_segundo, 4(R5)

  CLR    R0                    ;sucesso! (como pode dar erro?)
  RTS    r7
		
;		
;------------------------------------------------------------------------------
;	Inicializa o timer interno do kernel com o valor informado em R5,
;		que estará em formato de 16 bits, sem sinal. 
;	Esse valor estará informado o valor a ser programado no timer, em milissegundos. 
;------------------------------------------------------------------------------
_SETTIMER:
  CMP R5, #0
  BLT erro_timer

  MOV R5, timer_tempo
  CLR R0
  RTS R7
erro_timer:
  MOV #1, R0
  RTS    R7

;		
;------------------------------------------------------------------------------
;	Retorna ao programa de aplicação o valor atual do timer interno do kernel,
;		que foi programado com a função _SETTIMER.
;	Esse valor deve ser retornado no registrador R0.
;------------------------------------------------------------------------------
_GETTIMER:
  MOV timer_tempo, R0
  RTS    R7


	


	

